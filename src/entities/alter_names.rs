//! SeaORM Entity. Generated by sea-orm-codegen 0.5.0

use std::collections::HashMap;
use async_graphql::async_trait::async_trait;
use async_graphql::dataloader::{DataLoader, Loader};
use async_graphql::{ComplexObject, Context, Object, SimpleObject};
use itertools::Itertools;
use sea_orm::EntityTrait;
use sea_orm::Condition;
use sea_orm::entity::prelude::*;
use crate::entities::{Query, SqliteLoader};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel,Eq,Hash,SimpleObject)]
#[sea_orm(table_name = "alter_names")]
#[graphql(name = "AlterName")]
pub struct Model {
    pub part_id: i32,
    pub name: String,
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: i32,
}

#[async_trait]
impl Loader<Model> for SqliteLoader {
    type Value = Vec<Model>;
    type Error = ();

    async fn load(&self, keys: &[Model]) -> Result<HashMap<Model, Self::Value>, Self::Error> {
        let mut condition = Condition::any();
        let mut rs : HashMap<Model,Vec<Model>> = HashMap::new();
        let lookById =keys.iter().filter(|key| {key.id!=0}).map(|model| {model.id}).collect_vec();
        let lookByPartId = keys.iter().filter(|key| {key.part_id!=0}).map(|model| {model.part_id}).collect_vec();
        let lookByName = keys.iter().filter(|key| {!key.name.is_empty()}).map(|model| {&model.name}).collect_vec();
        if !lookById.is_empty(){
            condition=condition.add(Column::Id.is_in(lookById));
        }
        if !lookByPartId.is_empty(){
            condition=condition.add(Column::PartId.is_in(lookByPartId));
        }
        for str in lookByName {
            condition=condition.add(Column::Name.like(str.as_str()));
        }
        let db_rs = Entity::find().filter(condition).all(&self.pool).await.unwrap();
        for key in keys {
            if key.id!=0{
                rs.insert(key.to_owned(),db_rs.iter().filter(|rs| {rs.id==key.id}).map(|rs| {rs.clone()}).collect_vec());
            }
            if key.part_id!=0{
                rs.insert(key.to_owned(),db_rs.iter().filter(|rs| {rs.part_id==key.part_id}).map(|rs| {rs.clone()}).collect_vec());
            }
            if !key.name.is_empty(){
                rs.insert(key.to_owned(),db_rs.iter().filter(|rs| {rs.name.contains(&key.name)}).map(|rs| {rs.clone()}).collect_vec());
            }
        }
        Ok(rs)
    }
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::part_names::Entity",
        from = "Column::PartId",
        to = "super::part_names::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    PartNames,
}

impl Related<super::part_names::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::PartNames.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}
